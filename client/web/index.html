<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A* Pathfinding on Kathmandu Roads</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  </head>
  <body>
    <!-- <h2>Click on two points to find the shortest path</h2> -->
    <div id="map" style="width: 100%; height: 600px"></div>

    <script>
      var map = L.map("map").setView([27.7172, 85.324], 13);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "&copy; OpenStreetMap contributors",
      }).addTo(map);

      let sourceNode = null,
        destinationNode = null;

      // Load road edges
      fetch("http://127.0.0.1:5000/edges")
        .then((response) => response.json())
        .then((data) => {
          L.geoJSON(JSON.parse(data), { color: "black", weight: 1 }).addTo(map);
        })
        .catch((error) => console.error("Error loading edges:", error));

      // Load nodes
      fetch("http://127.0.0.1:5000/nodes")
        .then((response) => response.json())
        .then((data) => {
          L.geoJSON(JSON.parse(data), {
            pointToLayer: function (feature, latlng) {
              return L.circleMarker(latlng, {
                radius: 4,
                fillColor: "red",
                color: "red",
                fillOpacity: 1,
              }).on("click", function () {
                let nodeId = feature.properties.osmid || feature.id;

                if (!sourceNode) {
                  sourceNode = nodeId;
                  this.setStyle({ fillColor: "blue", color: "blue" });
                  console.log("✅ Source Node Selected:", sourceNode);
                } else if (!destinationNode) {
                  destinationNode = nodeId;
                  this.setStyle({ fillColor: "green", color: "green" });
                  console.log("✅ Destination Node Selected:", destinationNode);
                  findShortestPath();
                }
              });
            },
          }).addTo(map);
        })
        .catch((error) => console.error("❌ Error loading nodes:", error));

      function findShortestPath() {
        if (!sourceNode || !destinationNode) {
          alert("Select both source and destination nodes!");
          return;
        }

        console.log("Source Node: " + sourceNode);
        console.log("Destionation Node: " + destinationNode);

        fetch("http://127.0.0.1:5000/shortest_path", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            source: sourceNode,
            destination: destinationNode,
          }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.error) {
              alert(data.error);
              return;
            }

            // First, visualize explored paths
            animateExploration(data.explored, () => {
              // Then, animate the final shortest path
              animatePath(data.path);
            });
          })
          .catch((error) => console.error("Error finding path:", error));
      }

      function animateExploration(exploredEdges, callback) {
        let index = 0;
        let interval = setInterval(() => {
          if (index >= exploredEdges.length - 1) {
            clearInterval(interval);
            callback(); // Once done, start animating shortest path
          } else {
            let coords = exploredEdges[index];
            L.polyline(coords, { color: "yellow", weight: 10 }).addTo(map);
            index++;
          }
        }, 0); // Faster animation for exploration
      }

      function animatePath(pathCoords) {
        let index = 0;
        let interval = setInterval(() => {
          if (index >= pathCoords.length - 1) {
            clearInterval(interval);
          } else {
            L.polyline([pathCoords[index], pathCoords[index + 1]], {
              color: "blue",
              weight: 10,
            }).addTo(map);
            index++;
          }
        }, 0); // Slower animation for shortest path
      }
    </script>
  </body>
</html>
